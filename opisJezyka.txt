Język imperatywny na 24 pkt.
Na 15 punktów
  + 01 (trzy typy)
  + 02 (literały, arytmetyka, porównania)
  + 03 (zmienne, przypisanie)
  + 04 (print)
  + 05 (while, if)
  + 06 (funkcje lub procedury, rekurencja)
  + 07 (przez zmienną / przez wartość / in/out)
  - 08 (zmienne read-only i pętla for) // zamiast tego 07, można wybrać jedno
Na 20 punktów
  + 09 (przesłanianie i statyczne wiązanie)
  + 10 (obsługa błędów wykonania) -- dzielenie przez 0, wychodzenie poza zakres tablicy...
  + 11 (funkcje zwracające wartość)
Na 30 punktów
  + 12 (4) (statyczne typowanie)
  + 13 (2) (funkcje zagnieżdżone ze statycznym wiązaniem)
  + 14 (1) (rekordy/listy/tablice/tablice wielowymiarowe)
  - 15 (2) (krotki z przypisaniem)
  - 16 (1) (break, continue)
  - 17 (4) (funkcje wyższego rzędu, anonimowe, domknięcia)
  - 18 (3) (generatory)

Razem: 27


Opis języka:

Język o gramatyce podobnej do Tiny z rozszerzeniami jak w tabelce funkcjonalności powyżej
-- wymuszone nawiasy klamrowe dla if, else, while
np.

if (x > 0) { 
    x-- ; 
} else {
    return 0;
}

-- brak procedur oraz void, tylko funkcje zwracające int

-- tablice jednowymiarowe indeksowane int 
    -> wymóg określenia rozmiaru przy deklaracji, np.
    int[10] arr;
    arr[0] = arr[3] + 5 ;

-- pętla "for i in range (<Expr>)", ale bez dostępu do zmiennej i

bloki przysłaniające deklaracje zmiennych, z deklaracjami zawsze na górze bloku, lub bez:

int main [int x = 0] {
  print x; # x == 0
  [int x] {
    x = 1;
    print x; # x == 1
  }
  print x; # x == 0
}

-- "return" zwraca wynik jeśli jest wywołany w funkcji oraz rekurencyjnie przerywa pętle i bloki
while (i < n) {
  i = i+1;
  if (i == 2) {
    return 0; # przerwie pętlę
  }
}

-- program musi być postaci: <ciąg deklaracji funkcji>, blok "main":
int f(int x)  {
  return x;
}
main [int z]{
  z = 1;
  f(z);
}

-- program wywoływany za pomocą:
ghc --make Interpret.hs
./Interpret <nazwa pliku z kodem>